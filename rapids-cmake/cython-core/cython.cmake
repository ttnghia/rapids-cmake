# =============================================================================
# Copyright (c) 2023 CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.
# =============================================================================

include_guard(GLOBAL)

#[=======================================================================[.rst:
rapids_cython_compile
---------------------

.. versionadded:: v22.08.00

Invoke the `cython` compiler to transpile a pyx file.
The arguments to this function mirror the arguments to the Cython CLI.
The only exceptions are:
- Inputs are provided via the SOURCE_FILES parameter
- The output filename is determined automatically from the input and cannot be customized

.. code-block:: cmake

  rapids_cython_compile()

.. note::
  Use of this module assumes that Cython has been independently installed on the system.

#]=======================================================================]
function(rapids_cython_compile)
  list(APPEND CMAKE_MESSAGE_CONTEXT "rapids.cython.compile")

  find_program(CYTHON "cython" REQUIRED)

  # Each option corresponds to a command-line flag that accepts no arguments.
  # We store the indexed mapping so that we can process them programmatically.
  # TODO: The file generated by CREATE_LISTING goes to an undesirable location.
  # Not sure we can do much about that though since it isn't parametrizable.
  set(_rapids_cython_options CREATE_LISTING TIMESTAMPS FORCE VERBOSE EMBED_POSITIONS GDB NO_DOCSTRINGS ANNOTATE LINE_DIRECTIVES CPLUS PY2 PY3 PY3STR LENIENT CAPI_REXPORT_CINCLUDES FAST_FAIL WARNING_ERRORS WARNING_EXTRA DEPFILE)
  set(_rapids_cython_option_flags -l -t -f -v -p --gdb -D -a --line-directives --cplus -2 -3 --3str --lenient --capi-reexport-cincludes --fast-fail -Werror -Wextra -M)

  # Process the options into lower-case variables that will hold the
  # corresponding CLI flags.
  set(_rapids_cython_option_vars)
  foreach(option_name IN LISTS _rapids_cython_options)
    string(TOLOWER ${option_name} option_var_name)
    list(APPEND _rapids_cython_option_vars ${option_var_name})
  endforeach()

  # Each option corresponds to a command-line flag that accepts one argument.
  # We store the indexed mapping so that we can process them programmatically.
  set(_rapids_cython_one_value OUTPUT_FILE CLEANUP WORKING GDB_OUTDIR EMBED MODULE_NAME)
  set(_rapids_cython_one_value_has_default CLEANUP EMBED)
  set(_rapids_cython_one_value_flags -o --cleanup -w --gdb-outdir --embed --module-name)

  # Process the one-value args into lower-case variables that will hold the
  # corresponding CLI flags.
  set(_rapids_cython_one_value_vars)
  foreach(option_name IN LISTS _rapids_cython_one_value)
    string(TOLOWER ${option_name} option_var_name)
    list(APPEND _rapids_cython_one_value_vars ${option_var_name})
  endforeach()

  # Multi-value arguments require bespoke logic and don't share preprocessing.
  # TODO: Does it make sense to accept multiple files at once? It may not since
  # downstream CMake code will always have to take the generated C++ and pass
  # it to python_add_library and that accepts a list of source files, and there
  # will have to be a correspondence between the generated extension module and
  # the file.
  set(_rapids_cython_multi_value SOURCE_FILES INCLUDE_DIRS DIRECTIVES COMPILE_TIME_ENV)

  cmake_parse_arguments(_RAPIDS_COMPILE "${_rapids_cython_options}" "${_rapids_cython_one_value}"
                        "${_rapids_cython_multi_value}" ${ARGN})

  # Handle all options
  list(LENGTH _rapids_cython_options num_options)
  math(EXPR num_options "${num_options} - 1")
  foreach(i RANGE ${num_options})
    list(GET _rapids_cython_options ${i} option_name)
    list(GET _rapids_cython_option_vars ${i} option_var_name)
    set(option_value ${_RAPIDS_COMPILE_${option_name}})

    if(${option_value})
      list(GET _rapids_cython_option_flags ${i} option_flag)
      set(${option_var_name} ${option_flag})
    else()
      set(${option_var_name} "")
    endif()
  endforeach()

  # Validate that only a single PY argument was provided
  # TODO: Do we need to check this, or can we rely on the underlying `cython`
  # invocation to provide a sufficiently meaningful error here?
  set(num_py_args 0)
  if(${_RAPIDS_COMPILE_PY2})
    math(EXPR num_py_args "${num_py_args} + 1")
  endif()
  if(${_RAPIDS_COMPILE_PY3})
    math(EXPR num_py_args "${num_py_args} + 1")
  endif()
  if(${_RAPIDS_COMPILE_PY3STR})
    math(EXPR num_py_args "${num_py_args} + 1")
  endif()
  
  if(num_py_args GREATER 1)
    message(FATAL_ERROR "Only one of PY2, PY3, and PY3STR may be provided")
  endif()
  
  # Handle one-value args
  list(LENGTH _rapids_cython_one_value num_one_value)
  math(EXPR num_one_value "${num_one_value} - 1")
  foreach(i RANGE ${num_one_value})
    list(GET _rapids_cython_one_value ${i} option_name)
    list(GET _rapids_cython_one_value_vars ${i} option_var_name)

    # If the parameter was provided without a value, check if Cython provides
    # a default. If so, pass the flag without arguments, otherwise raise an
    # error.
    if(option_name IN_LIST _RAPIDS_COMPILE_KEYWORDS_MISSING_VALUES)
      if (option_name IN_LIST _rapids_cython_one_value_has_default)
        list(GET _rapids_cython_one_value_flags ${i} option_flag)
        set(${option_var_name} ${option_flag})
      else()
        message(FATAL_ERROR "Option ${option_name} must be provided with a single argument")
      endif()
    # If the parameter was provided with the value, set it correctly.
    elseif(DEFINED "_RAPIDS_COMPILE_${option_name}")
      list(GET _rapids_cython_one_value_flags ${i} option_flag)
      # TODO: Based on the CLI help the --embed option seems to use a syntax
      # with an equals sign (--embed=X rather than --embed X). If that is
      # correct, may need a small special-casing here.
      set(${option_var_name} "${option_flag} ${_RAPIDS_COMPILE_${option_name}}")
    endif()
  endforeach()

  # Now handle the multi-value args. These generally need different treatments
  if(NOT DEFINED _RAPIDS_COMPILE_SOURCE_FILES)
    message(FATAL_ERROR "You must provide a list of source files to compile")
  endif()

  set(include_dirs)
  if(DEFINED _RAPIDS_COMPILE_INCLUDE_DIRS)
    foreach(dir IN LISTS _RAPIDS_COMPILE_INCLUDE_DIRS)
      set(include_dirs "${include_dirs} -I ${dir}")
    endforeach()
  endif()

  set(directives)
  if(DEFINED _RAPIDS_COMPILE_DIRECTIVES)
    list(JOIN _RAPIDS_COMPILE_DIRECTIVES "," directives)
    set(directives "-X ${directives}")
  endif()

  set(compile_time_env)
  if(DEFINED _RAPIDS_COMPILE_COMPILE_TIME_ENV)
    list(JOIN _RAPIDS_COMPILE_COMPILE_TIME_ENV "," compile_time_env)
    set(compile_time_env "-X ${compile_time_env}")
  endif()

  # Combine arguments into a usable string
  set(args)
  foreach(arg IN LISTS _rapids_cython_option_vars)
    if(${arg})
      set(args "${args} ${${arg}}")
    endif()
  endforeach()

  foreach(arg IN LISTS _rapids_cython_one_value_vars)
    if(${arg})
      set(args "${args} ${${arg}}")
    endif()
  endforeach()

  # Generate a list of arguments that may be passed directly to add_custom_command
  set(args "${args} ${include_dirs} ${directives} ${compile_time_env}")
  separate_arguments(args NATIVE_COMMAND "${args}")

  # Determine the extension for the files.
  set(_ext ".c")
  if(_RAPIDS_COMPILE_CPLUS)
    set(_ext ".cxx")
  endif()

  # Maintain list of generated targets
  set(CREATED_FILES "")

  foreach(cython_filename IN LISTS _RAPIDS_COMPILE_SOURCE_FILES)
    cmake_path(GET cython_filename FILENAME cython_module)
    cmake_path(REPLACE_EXTENSION cython_module "${_ext}" OUTPUT_VARIABLE cpp_filename)
    cmake_path(REPLACE_FILENAME cython_filename ${cpp_filename} OUTPUT_VARIABLE cpp_filename)
    cmake_path(REMOVE_EXTENSION cython_module)

    add_custom_command(
      OUTPUT ${cpp_filename}
      DEPENDS ${cython_filename}
      VERBATIM
      # TODO: Is setting the input and output paths this way a robust solution,
      # or are there cases where it might be problematic?
      COMMAND "${CYTHON}" ${args} "${CMAKE_CURRENT_SOURCE_DIR}/${cython_filename}" --output-file
              "${CMAKE_CURRENT_BINARY_DIR}/${cpp_filename}")

    list(APPEND CREATED_FILES "${CMAKE_CURRENT_BINARY_DIR}/${cpp_filename}")
  endforeach()

  set(RAPIDS_COMPILE_CREATED_FILES ${CREATED_FILES} PARENT_SCOPE)
endfunction()
